"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var field_1 = require("./field");
var lodash = require("lodash");
var ValidationEngine = (function () {
    function ValidationEngine() {
    }
    ValidationEngine.ValidateFields = function (validationSchema, testData) {
        var lengthValidator = function (value, minlength, maxlength) {
            var failed = new Array();
            if (minlength && (value.length < minlength)) {
                failed.push("minlength");
            }
            if (maxlength && (value.length > maxlength)) {
                failed.push("maxlength");
            }
            return failed;
        };
        var sizeValidator = function (value, lt, gt) {
            var failed = new Array();
            if (lt && (value > lt)) {
                failed.push("lt");
            }
            if (gt && (value < gt)) {
                failed.push("gt");
            }
            return failed;
        };
        var regexValidator = function (value, regex) {
            return regex.test(value) ? [] : ["regex"];
        };
        var typeValidator = function (value, expected) {
            var failed = [];
            switch (expected) {
                case field_1.FieldType.Float:
                    if (isNaN(value) || typeof value === "string") {
                        failed.push("float");
                    }
                    break;
                case field_1.FieldType.Number:
                    if (isNaN(value) || typeof value === "string") {
                        failed.push("number");
                    }
                    break;
                case field_1.FieldType.List:
                    if (Object.prototype.toString.call(value) !== '[object Array]') {
                        failed.push("list");
                    }
                    break;
                case field_1.FieldType.Object:
                    if (Object.prototype.toString.call(value) !== '[object Object]') {
                        failed.push("object");
                    }
                    break;
                case field_1.FieldType.String:
                    if (typeof value !== "string") {
                        failed.push("string");
                    }
                    break;
            }
            return failed;
        };
        var stringValidator = function (value, expected) {
            var failed = new Array();
            switch (expected) {
                case field_1.StringType.Alpha:
                    if (typeof value === "string") {
                        if (!(/^[a-zA-Z]+$/.test(value))) {
                            failed.push("alpha");
                        }
                    }
                    else {
                        failed.push("alpha");
                    }
                    break;
                case field_1.StringType.AlphaNumeric:
                    if (typeof value === "string") {
                        if (!(/^[a-z0-9]+$/i.test(value))) {
                            failed.push("alphanumeric");
                        }
                    }
                    else {
                        failed.push("alphanumeric");
                    }
                    break;
                case field_1.StringType.Numeric:
                    var testValue = parseInt(value);
                    if (isNaN(testValue)) {
                        failed.push("numeric");
                    }
                    break;
                case field_1.StringType.Date:
                    var dateValue = parseInt(value);
                    if (isNaN(dateValue)) {
                        failed.push("date");
                    }
                    break;
                case field_1.StringType.Email:
                    var emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                    if (!(emailRegex.test(value))) {
                        failed.push("email");
                    }
                    break;
            }
            return failed;
        };
        var validator = function (schema, data) {
            var fieldValidation = {};
            schema.forEach(function (fieldSchema) {
                var fieldData = data[fieldSchema.name];
                var recentResult = [];
                var done = false;
                if (fieldSchema.required && !(fieldData)) {
                    recentResult.push("required");
                }
                else if (fieldData) {
                    if (fieldSchema.value) {
                        fieldValidation[fieldSchema.name] = validator(fieldSchema.value, fieldData);
                        done = true;
                    }
                    else {
                        if (fieldSchema.minlength || fieldSchema.maxlength) {
                            lengthValidator(fieldData, fieldSchema.minlength, fieldSchema.maxlength).forEach(function (fails) { return recentResult.push(fails); });
                        }
                        if (fieldSchema.lt || fieldSchema.gt) {
                            sizeValidator(fieldData, fieldSchema.lt, fieldSchema.gt).forEach(function (fails) { return recentResult.push(fails); });
                        }
                        if (fieldSchema.regex) {
                            regexValidator(fieldData, fieldSchema.regex).forEach(function (fails) { return recentResult.push(fails); });
                        }
                        if (fieldSchema.type) {
                            typeValidator(fieldData, fieldSchema.type).forEach(function (fails) { return recentResult.push(fails); });
                        }
                        if (fieldSchema.stringType) {
                            stringValidator(fieldData, fieldSchema.stringType).forEach(function (fails) { return recentResult.push(fails); });
                        }
                    }
                }
                if (!done)
                    if (recentResult.length > 0)
                        fieldValidation[fieldSchema.name] = recentResult;
            });
            return fieldValidation;
        };
        var abstractResult = validator(validationSchema, testData);
        if (!(lodash.isEmpty(abstractResult))) {
            abstractResult['errors'] = true;
        }
        return abstractResult;
    };
    ValidationEngine.SanitizeFields = function (validationSchema, validationResult, testData) {
        var sanitizer = function (schema, result, data) {
            var reconstruct = {};
            schema.forEach(function (fieldSchema) {
                if (fieldSchema.value) {
                    var reconcept = sanitizer(fieldSchema.value, result[fieldSchema.name], data[fieldSchema.name]);
                    if (!(lodash.isEmpty(reconcept))) {
                        reconstruct[fieldSchema.name] = reconcept;
                    }
                }
                else {
                    if (!(result[fieldSchema.name])) {
                        reconstruct[fieldSchema.name] = data[fieldSchema.name];
                    }
                }
            });
            return reconstruct;
        };
        var abstractResult = sanitizer(validationSchema, validationResult, testData);
        return abstractResult;
    };
    ValidationEngine.GetField = function (validationSchema, validationResult, testData, fieldName, defaultValue) {
        var fieldGetter = function (schema, result, field, data) {
            var DefaultValue;
            var subs = field.split(".");
            if (subs.length == 1) {
                if (result[field]) {
                    DefaultValue = defaultValue;
                }
                else {
                    schema.filter(function (item) {
                        if (item.name === field) {
                            if (item.type === field_1.FieldType.Number) {
                                DefaultValue = parseInt(data[field]);
                            }
                            else if (item.type === field_1.FieldType.Float) {
                                DefaultValue = parseFloat(data[field]);
                            }
                            else {
                                DefaultValue = data[item.name];
                            }
                        }
                    });
                }
            }
            else {
                var compiledValue_1 = "";
                subs.forEach(function (item, index) {
                    if (index != 0)
                        compiledValue_1 += item;
                });
                var newSchema_1;
                schema.forEach(function (item) {
                    if (item.name == subs[0]) {
                        newSchema_1 = item.value;
                    }
                });
                var newResult = result[subs[0]];
                DefaultValue = fieldGetter(newSchema_1, newResult, compiledValue_1, data[subs[0]]);
            }
            return DefaultValue;
        };
        var processedData = fieldGetter(validationSchema, validationResult, fieldName, testData);
        return processedData;
    };
    return ValidationEngine;
}());
exports.ValidationEngine = ValidationEngine;
